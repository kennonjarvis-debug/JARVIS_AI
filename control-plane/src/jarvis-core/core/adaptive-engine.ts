/**
 * Jarvis Adaptive Engine
 * Self-learning and optimization system
 *
 * Tracks performance, detects anomalies, suggests improvements,
 * and auto-optimizes low-risk actions.
 */

import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Performance metric tracked by the adaptive engine
 */
export interface PerformanceMetric {
  id: string;
  moduleName: string;
  metricName: string;
  value: number;
  timestamp: Date;
  metadata?: Record<string, any>;
}

/**
 * Anomaly detected by the adaptive engine
 */
export interface Anomaly {
  id: string;
  moduleName: string;
  type: 'performance' | 'error' | 'resource' | 'behavior';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  detectedAt: Date;
  resolved: boolean;
  resolvedAt?: Date;
  metrics?: Record<string, any>;
}

/**
 * Improvement suggestion generated by the adaptive engine
 */
export interface Improvement {
  id: string;
  moduleName: string;
  type: 'optimization' | 'configuration' | 'architecture' | 'workflow';
  clearanceLevel: 'low' | 'medium' | 'high';
  title: string;
  description: string;
  expectedImpact: string;
  implementationSteps?: string[];
  autoApplicable: boolean;
  applied: boolean;
  appliedAt?: Date;
  createdAt: Date;
}

/**
 * Learning record for the adaptive engine
 */
export interface LearningRecord {
  actionId: string;
  moduleName: string;
  actionType: string;
  outcomeSuccess: boolean;
  performanceImpact: number; // -100 to +100
  timestamp: Date;
  learnings: string[];
}

/**
 * Adaptive Engine - Core learning and optimization system
 */
export class AdaptiveEngine extends EventEmitter {
  private static instance: AdaptiveEngine;
  private metrics: PerformanceMetric[] = [];
  private anomalies: Anomaly[] = [];
  private improvements: Improvement[] = [];
  private learningHistory: LearningRecord[] = [];
  private maxHistorySize = 10000;
  private logPath = path.join(process.cwd(), 'logs/jarvis/adaptive-history.log');

  private constructor() {
    super();
    this.ensureLogDirectory();
  }

  /**
   * Get singleton instance
   */
  static getInstance(): AdaptiveEngine {
    if (!AdaptiveEngine.instance) {
      AdaptiveEngine.instance = new AdaptiveEngine();
    }
    return AdaptiveEngine.instance;
  }

  /**
   * Ensure log directory exists
   */
  private async ensureLogDirectory(): Promise<void> {
    const dir = path.dirname(this.logPath);
    try {
      await fs.mkdir(dir, { recursive: true });
    } catch (error) {
      logger.error('Failed to create adaptive log directory', {
        error: (error as Error).message,
      });
    }
  }

  /**
   * Record a performance metric
   */
  async recordMetric(metric: Omit<PerformanceMetric, 'id' | 'timestamp'>): Promise<void> {
    const fullMetric: PerformanceMetric = {
      id: this.generateId(),
      timestamp: new Date(),
      ...metric,
    };

    this.metrics.push(fullMetric);
    this.trimHistory(this.metrics, this.maxHistorySize);

    await this.logToFile({
      type: 'metric',
      data: fullMetric,
    });

    this.emit('metric:recorded', fullMetric);
  }

  /**
   * Analyze performance across all modules
   */
  async analyzePerformance(): Promise<{
    overallScore: number;
    moduleScores: Record<string, number>;
    insights: string[];
  }> {
    logger.info('Running performance analysis...');

    const moduleMetrics = this.groupMetricsByModule();
    const moduleScores: Record<string, number> = {};
    const insights: string[] = [];

    for (const [moduleName, metrics] of Object.entries(moduleMetrics)) {
      const avgValue = metrics.reduce((sum, m) => sum + m.value, 0) / metrics.length;
      moduleScores[moduleName] = avgValue;

      if (avgValue < 50) {
        insights.push(`Module "${moduleName}" is performing below average (score: ${Math.round(avgValue)})`);
      } else if (avgValue > 90) {
        insights.push(`Module "${moduleName}" is performing exceptionally well (score: ${Math.round(avgValue)})`);
      }
    }

    const overallScore = Object.values(moduleScores).reduce((sum, score) => sum + score, 0) /
                         Object.keys(moduleScores).length || 0;

    await this.logToFile({
      type: 'performance_analysis',
      data: { overallScore, moduleScores, insights },
    });

    return { overallScore, moduleScores, insights };
  }

  /**
   * Detect anomalies in system behavior
   */
  async detectAnomalies(): Promise<Anomaly[]> {
    logger.info('Running anomaly detection...');

    const newAnomalies: Anomaly[] = [];

    // Analyze recent metrics for each module
    const moduleMetrics = this.groupMetricsByModule();

    for (const [moduleName, metrics] of Object.entries(moduleMetrics)) {
      // Get recent metrics (last hour)
      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
      const recentMetrics = metrics.filter(m => m.timestamp >= oneHourAgo);

      if (recentMetrics.length < 2) continue;

      // Check for sudden performance drops
      const avgRecent = recentMetrics.slice(-10).reduce((sum, m) => sum + m.value, 0) / Math.min(10, recentMetrics.length);
      const avgPrevious = recentMetrics.slice(-20, -10).reduce((sum, m) => sum + m.value, 0) / Math.min(10, recentMetrics.length);

      if (avgRecent < avgPrevious * 0.7) {
        // 30% performance drop
        newAnomalies.push({
          id: this.generateId(),
          moduleName,
          type: 'performance',
          severity: avgRecent < avgPrevious * 0.5 ? 'high' : 'medium',
          description: `Performance dropped by ${Math.round(((avgPrevious - avgRecent) / avgPrevious) * 100)}%`,
          detectedAt: new Date(),
          resolved: false,
          metrics: { avgRecent, avgPrevious },
        });
      }
    }

    // Add new anomalies to tracking
    this.anomalies.push(...newAnomalies);
    this.trimHistory(this.anomalies, this.maxHistorySize);

    if (newAnomalies.length > 0) {
      await this.logToFile({
        type: 'anomalies_detected',
        data: newAnomalies,
      });

      this.emit('anomalies:detected', newAnomalies);
    }

    return newAnomalies;
  }

  /**
   * Suggest improvements based on performance analysis
   */
  async suggestImprovements(): Promise<Improvement[]> {
    logger.info('Generating improvement suggestions...');

    const newImprovements: Improvement[] = [];
    const analysis = await this.analyzePerformance();

    // Suggest improvements for low-performing modules
    for (const [moduleName, score] of Object.entries(analysis.moduleScores)) {
      if (score < 70) {
        newImprovements.push({
          id: this.generateId(),
          moduleName,
          type: 'optimization',
          clearanceLevel: score < 50 ? 'medium' : 'low',
          title: `Optimize ${moduleName} module performance`,
          description: `Module is performing at ${Math.round(score)}%. Consider caching, reducing API calls, or optimizing algorithms.`,
          expectedImpact: `${Math.round((100 - score) / 2)}% performance increase`,
          autoApplicable: score >= 50, // Only auto-apply for moderately performing modules
          applied: false,
          createdAt: new Date(),
        });
      }
    }

    // Add improvements to tracking
    this.improvements.push(...newImprovements);
    this.trimHistory(this.improvements, this.maxHistorySize);

    if (newImprovements.length > 0) {
      await this.logToFile({
        type: 'improvements_suggested',
        data: newImprovements,
      });

      this.emit('improvements:suggested', newImprovements);
    }

    return newImprovements;
  }

  /**
   * Auto-optimize low-risk improvements
   */
  async autoOptimizeIfLowRisk(): Promise<number> {
    logger.info('Running auto-optimization for low-risk improvements...');

    const lowRiskImprovements = this.improvements.filter(
      i => !i.applied && i.autoApplicable && i.clearanceLevel === 'low'
    );

    let optimized = 0;

    for (const improvement of lowRiskImprovements) {
      try {
        // Apply the improvement (simplified - would contain actual implementation)
        logger.info(`Auto-applying improvement: ${improvement.title}`, {
          moduleName: improvement.moduleName,
          type: improvement.type,
        });

        // Mark as applied
        improvement.applied = true;
        improvement.appliedAt = new Date();

        // Record learning
        await this.recordLearning({
          actionId: improvement.id,
          moduleName: improvement.moduleName,
          actionType: 'auto_optimization',
          outcomeSuccess: true,
          performanceImpact: 10, // Assume positive impact
          timestamp: new Date(),
          learnings: [`Auto-applied ${improvement.type} improvement for ${improvement.moduleName}`],
        });

        optimized++;

        this.emit('improvement:applied', improvement);
      } catch (error) {
        logger.error(`Failed to auto-apply improvement: ${improvement.title}`, {
          error: (error as Error).message,
        });
      }
    }

    if (optimized > 0) {
      await this.logToFile({
        type: 'auto_optimization_complete',
        data: { optimized, improvements: lowRiskImprovements.slice(0, optimized) },
      });
    }

    return optimized;
  }

  /**
   * Record a learning from an action outcome
   */
  async recordLearning(record: LearningRecord): Promise<void> {
    this.learningHistory.push(record);
    this.trimHistory(this.learningHistory, this.maxHistorySize);

    await this.logToFile({
      type: 'learning_recorded',
      data: record,
    });

    this.emit('learning:recorded', record);
  }

  /**
   * Get learning insights
   */
  getLearningInsights(): {
    totalLearnings: number;
    successRate: number;
    avgPerformanceImpact: number;
    topLearnings: string[];
  } {
    const totalLearnings = this.learningHistory.length;
    const successCount = this.learningHistory.filter(l => l.outcomeSuccess).length;
    const successRate = totalLearnings > 0 ? (successCount / totalLearnings) * 100 : 0;
    const avgPerformanceImpact = totalLearnings > 0 ?
      this.learningHistory.reduce((sum, l) => sum + l.performanceImpact, 0) / totalLearnings : 0;

    const topLearnings = this.learningHistory
      .filter(l => l.outcomeSuccess)
      .slice(-10)
      .flatMap(l => l.learnings);

    return {
      totalLearnings,
      successRate,
      avgPerformanceImpact,
      topLearnings,
    };
  }

  /**
   * Get current anomalies
   */
  getAnomalies(unresolved = true): Anomaly[] {
    return unresolved ? this.anomalies.filter(a => !a.resolved) : this.anomalies;
  }

  /**
   * Get improvements
   */
  getImprovements(unapplied = true): Improvement[] {
    return unapplied ? this.improvements.filter(i => !i.applied) : this.improvements;
  }

  /**
   * Resolve an anomaly
   */
  async resolveAnomaly(anomalyId: string): Promise<boolean> {
    const anomaly = this.anomalies.find(a => a.id === anomalyId);
    if (!anomaly) return false;

    anomaly.resolved = true;
    anomaly.resolvedAt = new Date();

    await this.logToFile({
      type: 'anomaly_resolved',
      data: anomaly,
    });

    this.emit('anomaly:resolved', anomaly);
    return true;
  }

  /**
   * Group metrics by module
   */
  private groupMetricsByModule(): Record<string, PerformanceMetric[]> {
    const grouped: Record<string, PerformanceMetric[]> = {};

    for (const metric of this.metrics) {
      if (!grouped[metric.moduleName]) {
        grouped[metric.moduleName] = [];
      }
      grouped[metric.moduleName].push(metric);
    }

    return grouped;
  }

  /**
   * Trim history arrays to max size
   */
  private trimHistory<T>(array: T[], maxSize: number): void {
    if (array.length > maxSize) {
      array.splice(0, array.length - maxSize);
    }
  }

  /**
   * Log to file
   */
  private async logToFile(entry: { type: string; data: any }): Promise<void> {
    try {
      const logEntry = JSON.stringify({
        ...entry,
        timestamp: new Date().toISOString(),
      }) + '\n';

      await fs.appendFile(this.logPath, logEntry, 'utf8');
    } catch (error) {
      logger.error('Failed to write to adaptive log', {
        error: (error as Error).message,
      });
    }
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return `adaptive-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get statistics
   */
  getStats(): {
    metricsRecorded: number;
    anomaliesDetected: number;
    unresolvedAnomalies: number;
    improvementsSuggested: number;
    improvementsApplied: number;
    learningRecords: number;
  } {
    return {
      metricsRecorded: this.metrics.length,
      anomaliesDetected: this.anomalies.length,
      unresolvedAnomalies: this.anomalies.filter(a => !a.resolved).length,
      improvementsSuggested: this.improvements.length,
      improvementsApplied: this.improvements.filter(i => i.applied).length,
      learningRecords: this.learningHistory.length,
    };
  }
}

// Export singleton instance
export const adaptiveEngine = AdaptiveEngine.getInstance();
